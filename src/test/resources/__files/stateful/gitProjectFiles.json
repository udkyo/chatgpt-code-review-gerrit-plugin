{
  "test_file_1.py": "from typing import Any, Callable, Type, Union\nimport importlib\n\n__all__ = [\"importclass\", \"preprocess_classes\", \"TypeClassOrPath\"]\n\nTypeClassOrPath = Union[Type, str]\n\n\ndef importclass(\n    module_name: str,\n    class_name: Union[str, None] = None\n) -> Type:\n    \"\"\"\n    Dynamically import a class from a specified module.\n\n    :param module_name: The name of the module to import.\n    :param class_name: The name of the class in the module to import. Defaults to None.\n    :return: The dynamically imported class.\n    \"\"\"\n    if not class_name:\n        module_name, class_name = module_name.rsplit('.', 1)\n    loaded_module = importclass(module_name, fromlist=[class_name])\n    return getattr(loaded_module, class_name)\n\n\ndef preprocess_classes(func: Callable) -> Callable:\n    \"\"\"Decorator to convert dot-notated class paths into strings from positional arguments.\"\"\"\n    def __preprocess_classes_wrapper(*all_classes: TypeClassOrPath, **kwargs: Any) -> Any:\n        \"\"\"\n        Dynamically import classes if they are passed as strings.\n\n        :param all_classes: A variable number of class paths (strings or actual types).\n        :param kwargs: Any keyword arguments to pass to the decorated function.\n        :return: The result of the decorated function.\n        \"\"\"\n        classes_processed = (\n            class_id if isinstance(class_id, type)\n            else importclass(class_id)\n            for class_id in all_classes\n        )\n        return func(*classes_processed, *kwargs)\n    return __preprocess_classes_wrapper\n",
  "test_file_2.py": "from typing import Any\n\n__all__ = [\"SingletonMeta\"]\n\n\nclass SingletonMeta(type):\n    \"\"\"A metaclass to manage Singleton classes.\"\"\"\n\n    _instances: Any = {}\n\n    def __new__(cls, name, bases, dct) -> type:\n        \"\"\"Create the Singleton class and add the class method `destroy_singleton` to it.\"\"\"\n        def __destroy_singleton(_):\n            cls.destroy(name)\n\n        instance = super().__new__(cls, name, bases, dct)\n        setattr(instance, 'destroy_singleton', __destroy_singleton)\n        return instance\n\n    def __call__(cls, *args, **kwargs) -> type:\n        \"\"\"\n        Return the Singleton class instance, creating a new instance if one does not already exist.\n\n        :param args: Arguments to pass to the class constructor.\n        :param kwargs: Keyword arguments to pass to the class constructor.\n        :return: Singleton class instance.\n        \"\"\"\n        if cls not in cls._instances:\n            instance = super(SingletonMeta, cls).__call__(*args, **kwargs)\n            cls._instances[cls] = instance\n        return cls._instances[cls]\n\n    @classmethod\n    def destroy(cls, *class_names: str):\n        \"\"\"\n        Delete instances of Singleton classes based on provided class names.\n\n        :param class_names: Names of the Singleton class instances to destroy.\n                           If no class name is provided, instances of all Singleton classes are deleted.\n        \"\"\"\n        if class_names:\n            cls._instances = {k: v for k, v in cls._instances.items() if k.__name__ not in class_names}\n        else:\n            cls._instances = {}\n"
}